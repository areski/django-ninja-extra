{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Ninja Extra is a utility library built on top of Django Ninja for building and setting up APIs at incredible speed and performance. Requirements Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1 Key Features All Django-Ninja features are fully supported plus others below: Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease, specific or general Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Quick Example In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI from ninja_extra import APIController , route , router from ninja_extra.permissions import AllowAny api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @router ( '' , tags = [ 'Math' ], permissions = [ AllowAny ]) class MyController ( APIController ): @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MyController ) Now go to urls.py and add the following: ... from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ] Interactive API docs Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ): What next? To support this project, please give star it on Github","title":"Index"},{"location":"#requirements","text":"Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1","title":"Requirements"},{"location":"#key-features","text":"All Django-Ninja features are fully supported plus others below: Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease, specific or general Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector","title":"Key Features"},{"location":"#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"#quick-example","text":"In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI from ninja_extra import APIController , route , router from ninja_extra.permissions import AllowAny api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @router ( '' , tags = [ 'Math' ], permissions = [ AllowAny ]) class MyController ( APIController ): @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MyController ) Now go to urls.py and add the following: ... from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ]","title":"Quick Example"},{"location":"#interactive-api-docs","text":"Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"#what-next","text":"To support this project, please give star it on Github","title":"What next?"},{"location":"service_module_injector/","text":"Injector Django Ninja Extra APIController comes with dependency injector support. Dependencies to a APIController can be resolved at constructor level automatically. This is possible with python Injector library. Also, APIController injector works well with django_injector from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Module Registration You can also register an injector module. And Inject the service to the APIController constructor import logging import os from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router from typing import Any , cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class BucketFileUpload : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): raise NotImplementedError () def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): raise NotImplementedError () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = cast ( Any , settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= {file.filename} , bucket_name {bucket_name} , acl= {acl} , file_key= {file_key} )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= {filepath} , file_key= {file_key} , \" f \"bucket_name= {bucket_name} , acl= {acl} , delete_file_afterwards= {delete_file_afterwards} )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) api . register_injector_modules ( FileServiceModule )","title":"Service Module and Injector"},{"location":"service_module_injector/#injector","text":"Django Ninja Extra APIController comes with dependency injector support. Dependencies to a APIController can be resolved at constructor level automatically. This is possible with python Injector library. Also, APIController injector works well with django_injector from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController )","title":"Injector"},{"location":"service_module_injector/#module-registration","text":"You can also register an injector module. And Inject the service to the APIController constructor import logging import os from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router from typing import Any , cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class BucketFileUpload : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): raise NotImplementedError () def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): raise NotImplementedError () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = cast ( Any , settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= {file.filename} , bucket_name {bucket_name} , acl= {acl} , file_key= {file_key} )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= {filepath} , file_key= {file_key} , \" f \"bucket_name= {bucket_name} , acl= {acl} , delete_file_afterwards= {delete_file_afterwards} )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) api . register_injector_modules ( FileServiceModule )","title":"Module Registration"},{"location":"tutorial/","text":"Tutorial - Intro This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Create a Django project (If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject First steps Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI , route , APIController , router api = NinjaExtraAPI () @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Defining operation methods \"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the api or Django-Ninja router . The same operation functionalities are available on route class for APIController class Django Ninja Extra route function is an extra decorator for defining route function in your controller class. The router here is a short form of ControllerRouter , an Adapter class to Django-Ninja Router but without operational functions. It gives you global control of all routes defined in an APIController class. @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . get ( \"/path\" ) def get_operation ( self ): ... @route . post ( \"/path\" ) def post_operation ( self ): ... @route . put ( \"/path\" ) def put_operation ( self ): ... @route . delete ( \"/path\" ) def delete_operation ( self ): ... @route . patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @route . generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"intro"},{"location":"tutorial/#tutorial-intro","text":"This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja","title":"Tutorial - Intro"},{"location":"tutorial/#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"tutorial/#create-a-django-project","text":"(If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject","title":"Create a Django project"},{"location":"tutorial/#first-steps","text":"Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI , route , APIController , router api = NinjaExtraAPI () @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ]","title":"First steps"},{"location":"tutorial/#defining-operation-methods","text":"\"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the api or Django-Ninja router . The same operation functionalities are available on route class for APIController class Django Ninja Extra route function is an extra decorator for defining route function in your controller class. The router here is a short form of ControllerRouter , an Adapter class to Django-Ninja Router but without operational functions. It gives you global control of all routes defined in an APIController class. @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . get ( \"/path\" ) def get_operation ( self ): ... @route . post ( \"/path\" ) def post_operation ( self ): ... @route . put ( \"/path\" ) def put_operation ( self ): ... @route . delete ( \"/path\" ) def delete_operation ( self ): ... @route . patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @route . generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"Defining operation methods"},{"location":"tutorial/api_controller/","text":"APIController APIController is a borrowed term from C# environment. Controller is concept from MVC. Although Django is not an MVC framework, but we can mimic the concept generally. The APIController is an abstract class model that allows you to expose some class instance functions as route functions. It also supports dependency injection with Injector or Django injector . class APIController ( ABC , metaclass = APIControllerModelMetaclass ): ... Model Properties permission_classes List of default permission classes defined in a controller router auth List of default Authentication instances. As described in Django-Ninja Authentication . default: [] api Instance of NinjaExtraAPI at runtime. default: None auto_import states whether APIController should added to auto_controller import list. default: True get_router(cls) -> Optional[ControllerRouter] return controller to router instance if present and raises Exception is absent. get_path_operations(cls) -> DictStrAny container dict of route definition which are pass to Django-Ninja at runtime add_operation_from_route_function(cls, route_function: RouteFunction) A method overload for add_api_operation add_api_operation(cls, ...) Adds APIController route definitions to path operation get_route_functions(cls) -> Iterator[RouteFunction] Gets all registered route in an APIController get_permissions(self) Returns list of permission_classes instances check_permissions(self) Check permission when route function is invoked check_object_permissions(self, obj: Any) Checks object permissions. This is not automated. However, when called, it triggers all permission_classes has_object_permission function, just like in DRF","title":"APIController"},{"location":"tutorial/api_controller/#apicontroller","text":"APIController is a borrowed term from C# environment. Controller is concept from MVC. Although Django is not an MVC framework, but we can mimic the concept generally. The APIController is an abstract class model that allows you to expose some class instance functions as route functions. It also supports dependency injection with Injector or Django injector . class APIController ( ABC , metaclass = APIControllerModelMetaclass ): ...","title":"APIController"},{"location":"tutorial/api_controller/#model-properties","text":"","title":"Model Properties"},{"location":"tutorial/api_controller/#permission_classes","text":"List of default permission classes defined in a controller router","title":"permission_classes"},{"location":"tutorial/api_controller/#auth","text":"List of default Authentication instances. As described in Django-Ninja Authentication . default: []","title":"auth"},{"location":"tutorial/api_controller/#api","text":"Instance of NinjaExtraAPI at runtime. default: None","title":"api"},{"location":"tutorial/api_controller/#auto_import","text":"states whether APIController should added to auto_controller import list. default: True","title":"auto_import"},{"location":"tutorial/api_controller/#get_routercls-optionalcontrollerrouter","text":"return controller to router instance if present and raises Exception is absent.","title":"get_router(cls) -&gt; Optional[ControllerRouter]"},{"location":"tutorial/api_controller/#get_path_operationscls-dictstrany","text":"container dict of route definition which are pass to Django-Ninja at runtime","title":"get_path_operations(cls) -&gt; DictStrAny"},{"location":"tutorial/api_controller/#add_operation_from_route_functioncls-route_function-routefunction","text":"A method overload for add_api_operation","title":"add_operation_from_route_function(cls, route_function: RouteFunction)"},{"location":"tutorial/api_controller/#add_api_operationcls","text":"Adds APIController route definitions to path operation","title":"add_api_operation(cls, ...)"},{"location":"tutorial/api_controller/#get_route_functionscls-iteratorroutefunction","text":"Gets all registered route in an APIController","title":"get_route_functions(cls) -&gt; Iterator[RouteFunction]"},{"location":"tutorial/api_controller/#get_permissionsself","text":"Returns list of permission_classes instances","title":"get_permissions(self)"},{"location":"tutorial/api_controller/#check_permissionsself","text":"Check permission when route function is invoked","title":"check_permissions(self)"},{"location":"tutorial/api_controller/#check_object_permissionsself-obj-any","text":"Checks object permissions. This is not automated. However, when called, it triggers all permission_classes has_object_permission function, just like in DRF","title":"check_object_permissions(self, obj: Any)"},{"location":"tutorial/api_controller_permission/","text":"APIController Permissions The concept of these permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra . Limitations of object level permissions During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can't invoke has_object_permission . It has to be done manually Custom permissions To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , APIController , router , route class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @router ( \"\" , permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController ( APIController ): @route . get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word ) Permissions Supported Operands & (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: !(permissions.IsAuthenticated & ReadOnly)","title":"Controller Permissions"},{"location":"tutorial/api_controller_permission/#apicontroller-permissions","text":"The concept of these permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra .","title":"APIController Permissions"},{"location":"tutorial/api_controller_permission/#limitations-of-object-level-permissions","text":"During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can't invoke has_object_permission . It has to be done manually","title":"Limitations of object level permissions"},{"location":"tutorial/api_controller_permission/#custom-permissions","text":"To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , APIController , router , route class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @router ( \"\" , permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController ( APIController ): @route . get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word )","title":"Custom permissions"},{"location":"tutorial/api_controller_permission/#permissions-supported-operands","text":"& (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: !(permissions.IsAuthenticated & ReadOnly)","title":"Permissions Supported Operands"},{"location":"tutorial/api_controller_route/","text":"APIController Route Decorator To define an APIController function as route, it needs to be decorated with route The route decorator is like router class in Django-Ninja but the behaviour is different. Its main purpose is to define route function in APIController. For example from ninja_extra import route , APIController from ninja_extra.controllers import RouteFunction class MyController ( APIController ): @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route predefined method that helps create the following operations - GET - POST - PUT - DELETE - PATCH - GENERIC - for operation combination eg: methods=['POST', 'PATCH'] Initialization Parameters path it's a required uniques endpoint path string methods it's required a collection of endpoint operational mode eg: ['POST', 'PUT'] auth defines endpoint authentication method. default: NOT_SET response defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET operation_id it is an optional unique id that distinguishes operations in path view. default: NOT_SET summary it is an optional summary that describes your endpoint. default: None description it is an optional description that describes your endpoint. default: None tags It is a list of strings useful for endpoint grouping for documentation purpose. default: None deprecated it is an optional boolean parameter that declares an endpoint deprecated. default: None by_alias it is an optional parameter that is applied to filter response schema object. default: False exclude_unset it is an optional parameter that is applied to filter response schema object. default: False exclude_defaults it is an optional parameter that is applied to filter response schema object. default: False exclude_none it is an optional parameter that is applied to filter response schema object. default: False include_in_schema indicates whether an endpoint should appear on the swagger documentation. default: True url_name it gives a name to an endpoint which can be resolved using reverse function in django. default: None permissions defines collection route permissions. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class Async Route Definition Django-Ninja-Extra route class also supports async endpoint definition. This is only available on Django > 3.0 For Example import asyncio from ninja_extra import route , APIController from ninja_extra.controllers import AsyncRouteFunction class MyController ( APIController ): @route . get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Controller Routes"},{"location":"tutorial/api_controller_route/#apicontroller-route-decorator","text":"To define an APIController function as route, it needs to be decorated with route The route decorator is like router class in Django-Ninja but the behaviour is different. Its main purpose is to define route function in APIController. For example from ninja_extra import route , APIController from ninja_extra.controllers import RouteFunction class MyController ( APIController ): @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route predefined method that helps create the following operations - GET - POST - PUT - DELETE - PATCH - GENERIC - for operation combination eg: methods=['POST', 'PATCH']","title":"APIController Route Decorator"},{"location":"tutorial/api_controller_route/#initialization-parameters","text":"","title":"Initialization Parameters"},{"location":"tutorial/api_controller_route/#path","text":"it's a required uniques endpoint path string","title":"path"},{"location":"tutorial/api_controller_route/#methods","text":"it's required a collection of endpoint operational mode eg: ['POST', 'PUT']","title":"methods"},{"location":"tutorial/api_controller_route/#auth","text":"defines endpoint authentication method. default: NOT_SET","title":"auth"},{"location":"tutorial/api_controller_route/#response","text":"defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET","title":"response"},{"location":"tutorial/api_controller_route/#operation_id","text":"it is an optional unique id that distinguishes operations in path view. default: NOT_SET","title":"operation_id"},{"location":"tutorial/api_controller_route/#summary","text":"it is an optional summary that describes your endpoint. default: None","title":"summary"},{"location":"tutorial/api_controller_route/#description","text":"it is an optional description that describes your endpoint. default: None","title":"description"},{"location":"tutorial/api_controller_route/#tags","text":"It is a list of strings useful for endpoint grouping for documentation purpose. default: None","title":"tags"},{"location":"tutorial/api_controller_route/#deprecated","text":"it is an optional boolean parameter that declares an endpoint deprecated. default: None","title":"deprecated"},{"location":"tutorial/api_controller_route/#by_alias","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"by_alias"},{"location":"tutorial/api_controller_route/#exclude_unset","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_unset"},{"location":"tutorial/api_controller_route/#exclude_defaults","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_defaults"},{"location":"tutorial/api_controller_route/#exclude_none","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_none"},{"location":"tutorial/api_controller_route/#include_in_schema","text":"indicates whether an endpoint should appear on the swagger documentation. default: True","title":"include_in_schema"},{"location":"tutorial/api_controller_route/#url_name","text":"it gives a name to an endpoint which can be resolved using reverse function in django. default: None","title":"url_name"},{"location":"tutorial/api_controller_route/#permissions","text":"defines collection route permissions. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class","title":"permissions"},{"location":"tutorial/api_controller_route/#async-route-definition","text":"Django-Ninja-Extra route class also supports async endpoint definition. This is only available on Django > 3.0 For Example import asyncio from ninja_extra import route , APIController from ninja_extra.controllers import AsyncRouteFunction class MyController ( APIController ): @route . get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Async Route Definition"},{"location":"tutorial/api_controller_router/","text":"APIController Router The ControllerRouter which is router in short form, adapts APIController to Django-Ninja router. During api.register_controllers call, the APIController _router is pass to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter decoration Initialization Parameters prefix it is a required parameter that defines extra route prefix for all route functions defined in an APIController class auth It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET tags It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None permissions It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None controller: Optional[Type[\"APIController\"]] = None, It is APIController class decorated Quick Usage from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"Controller Router"},{"location":"tutorial/api_controller_router/#apicontroller-router","text":"The ControllerRouter which is router in short form, adapts APIController to Django-Ninja router. During api.register_controllers call, the APIController _router is pass to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter decoration","title":"APIController Router"},{"location":"tutorial/api_controller_router/#initialization-parameters","text":"","title":"Initialization Parameters"},{"location":"tutorial/api_controller_router/#prefix","text":"it is a required parameter that defines extra route prefix for all route functions defined in an APIController class","title":"prefix"},{"location":"tutorial/api_controller_router/#auth","text":"It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET","title":"auth"},{"location":"tutorial/api_controller_router/#tags","text":"It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None","title":"tags"},{"location":"tutorial/api_controller_router/#permissions","text":"It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None","title":"permissions"},{"location":"tutorial/api_controller_router/#controller-optionaltypeapicontroller-none","text":"It is APIController class decorated","title":"controller: Optional[Type[\"APIController\"]] = None,"},{"location":"tutorial/api_controller_router/#quick-usage","text":"from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"Quick Usage"},{"location":"tutorial/authentication/","text":"Authentication Intro Django Ninja Extra provides the same API for authorization and authentication. Automatic OpenAPI schema Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import APIController , route class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token class MyController ( APIController ): @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth } Global authentication In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication JWT Authentication if you want to use JWT authentication. See ninja-jwt","title":"Authentication"},{"location":"tutorial/authentication/#authentication","text":"","title":"Authentication"},{"location":"tutorial/authentication/#intro","text":"Django Ninja Extra provides the same API for authorization and authentication.","title":"Intro"},{"location":"tutorial/authentication/#automatic-openapi-schema","text":"Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import APIController , route class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token class MyController ( APIController ): @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth }","title":"Automatic OpenAPI schema"},{"location":"tutorial/authentication/#global-authentication","text":"In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication","title":"Global authentication"},{"location":"tutorial/authentication/#jwt-authentication","text":"if you want to use JWT authentication. See ninja-jwt","title":"JWT Authentication"},{"location":"tutorial/body_request/","text":"Request Body Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema . Info Read more on django-ninja body request Create your data model Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema from ninja_extra import APIController , route class Item ( Schema ): name : str description : str = None price : float quantity : int class ItemController ( APIController ): @route . post ( \"/items\" ) def create ( request , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Body Request"},{"location":"tutorial/body_request/#request-body","text":"Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema . Info Read more on django-ninja body request","title":"Request Body"},{"location":"tutorial/body_request/#create-your-data-model","text":"Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema from ninja_extra import APIController , route class Item ( Schema ): name : str description : str = None price : float quantity : int class ItemController ( APIController ): @route . post ( \"/items\" ) def create ( request , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Create your data model"},{"location":"tutorial/custom_exception/","text":"Custom Exception If you are coming from DRF, then you are use to APIException class. Django-Ninja-Extra has something similar with the same and a has created a handler for it. from ninja_extra.exceptions import APIException from ninja_extra import status from ninja_extra import router , APIController , route , NinjaExtraAPI class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @router ( '/users' , tags = [ \"exception\" ]) class MyController ( APIController ): @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Exception"},{"location":"tutorial/custom_exception/#custom-exception","text":"If you are coming from DRF, then you are use to APIException class. Django-Ninja-Extra has something similar with the same and a has created a handler for it. from ninja_extra.exceptions import APIException from ninja_extra import status from ninja_extra import router , APIController , route , NinjaExtraAPI class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @router ( '/users' , tags = [ \"exception\" ]) class MyController ( APIController ): @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Custom Exception"},{"location":"tutorial/pagination/","text":"Pagination Django Ninja Extra Pagination decorator gives you more pagination information, and it is very extensible. Usage from ninja_extra.pagination import paginate , PageNumberPaginationExtra from ninja_extra import router , APIController , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @router ( '/users' ) class UserController ( APIController ): @route . get ( '' , response = PageNumberPaginationExtra . get_response_schema ( schemas . UserSchema )) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Pagination"},{"location":"tutorial/pagination/#pagination","text":"Django Ninja Extra Pagination decorator gives you more pagination information, and it is very extensible.","title":"Pagination"},{"location":"tutorial/pagination/#usage","text":"from ninja_extra.pagination import paginate , PageNumberPaginationExtra from ninja_extra import router , APIController , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @router ( '/users' ) class UserController ( APIController ): @route . get ( '' , response = PageNumberPaginationExtra . get_response_schema ( schemas . UserSchema )) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Usage"},{"location":"tutorial/versioning/","text":"Versioning Different API version numbers With Django Ninja Extra it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , APIController , route , router @router ( '' ) class MyV1Controller ( APIController ): @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: from ninja_extra import NinjaExtraAPI , route , router from .api_v1 import MyV1Controller @router ( '' ) class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs Different business logic In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Versoning"},{"location":"tutorial/versioning/#versioning","text":"","title":"Versioning"},{"location":"tutorial/versioning/#different-api-version-numbers","text":"With Django Ninja Extra it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , APIController , route , router @router ( '' ) class MyV1Controller ( APIController ): @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: from ninja_extra import NinjaExtraAPI , route , router from .api_v1 import MyV1Controller @router ( '' ) class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs","title":"Different API version numbers"},{"location":"tutorial/versioning/#different-business-logic","text":"In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Different business logic"}]}