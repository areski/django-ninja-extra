{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Ninja Extra Django Ninja Extra is a utility library built on top of Django Ninja for building and setting up APIs at incredible speed and performance. It brings alot batteries to Django Ninja which are also extensible for customization. Key features: All Django-Ninja features: Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Plus Extra : Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease with defined permissions and authorizations at route level or controller level. Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector . Giving you the ability to inject API dependable services at the controller class constructor and utilizing them where needed Requirements Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1 Django-Ninja Benchmark Both Django-Ninja and Django-Ninja-Extra shares the same benchmark because Django-Ninja-Extra operational core is Django-Ninja Full documentation, visit . Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Usage In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI , APIController , route , router api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @router ( '/' , tags = [ 'Math' ], permissions = []) class MathAPI ( APIController ): @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MathAPI ) Now go to urls.py and add the following: ... from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ] Interactive API docs Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ): What next? To support this project, please give star it on Github","title":"Index"},{"location":"#django-ninja-extra","text":"Django Ninja Extra is a utility library built on top of Django Ninja for building and setting up APIs at incredible speed and performance. It brings alot batteries to Django Ninja which are also extensible for customization. Key features: All Django-Ninja features: Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Plus Extra : Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease with defined permissions and authorizations at route level or controller level. Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector . Giving you the ability to inject API dependable services at the controller class constructor and utilizing them where needed","title":"Django Ninja Extra"},{"location":"#requirements","text":"Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1","title":"Requirements"},{"location":"#django-ninja-benchmark","text":"Both Django-Ninja and Django-Ninja-Extra shares the same benchmark because Django-Ninja-Extra operational core is Django-Ninja Full documentation, visit .","title":"Django-Ninja Benchmark"},{"location":"#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"#usage","text":"In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI , APIController , route , router api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @router ( '/' , tags = [ 'Math' ], permissions = []) class MathAPI ( APIController ): @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MathAPI ) Now go to urls.py and add the following: ... from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ]","title":"Usage"},{"location":"#interactive-api-docs","text":"Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"#what-next","text":"To support this project, please give star it on Github","title":"What next?"},{"location":"ninja_schema/","text":"Ninja Schema Ninja Schema converts your Django ORM models to Pydantic schemas with more Pydantic features supported. Inspired by : django-ninja and djantic Key features: Custom Field Support : Ninja Schema converts django model to native pydantic types which gives you quick field validation out of the box. eg Enums, email, IPAddress, URLs, JSON, etc Field Validator : Fields can be validated with model_validator just like pydantic validator or root_validator . Info Visit Ninja Schema for More information","title":"Ninja Schema"},{"location":"ninja_schema/#ninja-schema","text":"Ninja Schema converts your Django ORM models to Pydantic schemas with more Pydantic features supported. Inspired by : django-ninja and djantic Key features: Custom Field Support : Ninja Schema converts django model to native pydantic types which gives you quick field validation out of the box. eg Enums, email, IPAddress, URLs, JSON, etc Field Validator : Fields can be validated with model_validator just like pydantic validator or root_validator . Info Visit Ninja Schema for More information","title":"Ninja Schema"},{"location":"service_module_injector/","text":"Dependency Injection Django Ninja Extra APIController support dependency injection. Dependencies to a APIController can be resolved at constructor level automatically with using @inject decorator. This is possible with python Injector library. Also, APIController injector works well with django_injector Info Read more Python Injector from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Module Registration You can also register an injector module. And Inject the service to the APIController constructor Create a module create a modules.py with the code below in your django-project import logging import os from typing import Any , cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class BucketFileUpload : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): raise NotImplementedError () def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): raise NotImplementedError () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = cast ( Any , settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= {file.filename} , bucket_name {bucket_name} , acl= {acl} , file_key= {file_key} )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= {filepath} , file_key= {file_key} , \" f \"bucket_name= {bucket_name} , acl= {acl} , delete_file_afterwards= {delete_file_afterwards} )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) Create a controller.py with the code below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router from .modules import BucketFileUpload , InMemoryBucketFileUpload @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Register your Module In your django settings.py , add your FileServiceModule module to the NinjaExtra settings ... MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware' , 'django.contrib.sessions.middleware.SessionMiddleware' , 'django.middleware.common.CommonMiddleware' , 'django.middleware.csrf.CsrfViewMiddleware' , 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'django.contrib.messages.middleware.MessageMiddleware' , 'django.middleware.clickjacking.XFrameOptionsMiddleware' , ] NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.modules.FileServiceModule' ] } ...","title":"Dependency Injection"},{"location":"service_module_injector/#dependency-injection","text":"Django Ninja Extra APIController support dependency injection. Dependencies to a APIController can be resolved at constructor level automatically with using @inject decorator. This is possible with python Injector library. Also, APIController injector works well with django_injector Info Read more Python Injector from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController )","title":"Dependency Injection"},{"location":"service_module_injector/#module-registration","text":"You can also register an injector module. And Inject the service to the APIController constructor","title":"Module Registration"},{"location":"service_module_injector/#create-a-module","text":"create a modules.py with the code below in your django-project import logging import os from typing import Any , cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class BucketFileUpload : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): raise NotImplementedError () def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): raise NotImplementedError () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = cast ( Any , settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= {file.filename} , bucket_name {bucket_name} , acl= {acl} , file_key= {file_key} )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= {filepath} , file_key= {file_key} , \" f \"bucket_name= {bucket_name} , acl= {acl} , delete_file_afterwards= {delete_file_afterwards} )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) Create a controller.py with the code below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router from .modules import BucketFileUpload , InMemoryBucketFileUpload @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController )","title":"Create a module"},{"location":"service_module_injector/#register-your-module","text":"In your django settings.py , add your FileServiceModule module to the NinjaExtra settings ... MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware' , 'django.contrib.sessions.middleware.SessionMiddleware' , 'django.middleware.common.CommonMiddleware' , 'django.middleware.csrf.CsrfViewMiddleware' , 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'django.contrib.messages.middleware.MessageMiddleware' , 'django.middleware.clickjacking.XFrameOptionsMiddleware' , ] NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.modules.FileServiceModule' ] } ...","title":"Register your Module"},{"location":"tutorial/","text":"Tutorial / Reference This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Create a Django project (If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject First steps Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI , route , APIController , router api = NinjaExtraAPI () @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Defining operation methods \"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the api or Django-Ninja router . The same operation functionalities are available on route class for APIController class Django Ninja Extra route function is an extra decorator for defining route function in your controller class. The router here is a short form of ControllerRouter , an Adapter class to Django-Ninja router but without operational functions. It also provides global control of all routes defined in any APIController class. @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . get ( \"/path\" ) def get_operation ( self ): ... @route . post ( \"/path\" ) def post_operation ( self ): ... @route . put ( \"/path\" ) def put_operation ( self ): ... @route . delete ( \"/path\" ) def delete_operation ( self ): ... @route . patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @route . generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"Quick Tutorial"},{"location":"tutorial/#tutorial-reference","text":"This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja","title":"Tutorial / Reference"},{"location":"tutorial/#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"tutorial/#create-a-django-project","text":"(If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject","title":"Create a Django project"},{"location":"tutorial/#first-steps","text":"Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI , route , APIController , router api = NinjaExtraAPI () @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ]","title":"First steps"},{"location":"tutorial/#defining-operation-methods","text":"\"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the api or Django-Ninja router . The same operation functionalities are available on route class for APIController class Django Ninja Extra route function is an extra decorator for defining route function in your controller class. The router here is a short form of ControllerRouter , an Adapter class to Django-Ninja router but without operational functions. It also provides global control of all routes defined in any APIController class. @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . get ( \"/path\" ) def get_operation ( self ): ... @route . post ( \"/path\" ) def post_operation ( self ): ... @route . put ( \"/path\" ) def put_operation ( self ): ... @route . delete ( \"/path\" ) def delete_operation ( self ): ... @route . patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @route . generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"Defining operation methods"},{"location":"tutorial/api_controller/","text":"Controller APIController is a borrowed term from C# environment. Controller is concept from MVC. Although Django is not an MVC framework, but we can mimic the concept generally. The APIController is an abstract class model that allows you to expose some class instance functions as route functions. It also supports dependency injection with Injector or Django injector . class APIController ( ABC , metaclass = APIControllerModelMetaclass ): ... Model Properties permission_classes List of default permission classes defined in a controller router auth List of default Authentication instances. As described in Django-Ninja Authentication . default: [] api Instance of NinjaExtraAPI at runtime. default: None auto_import states whether APIController should added to auto_controller import list. default: True get_router(cls) return controller to router instance if present and raises Exception is absent. get_path_operations(cls) container dict of route definition which are pass to Django-Ninja at runtime add_operation_from_route_function(cls, route_function: RouteFunction) A method overload for add_api_operation add_api_operation(cls, ...) Adds APIController route definitions to path operation get_route_functions(cls) Gets all registered route in an APIController get_permissions(self) Returns list of permission_classes instances check_permissions(self) Check permission when route function is invoked check_object_permissions(self, obj: Any) Checks object permissions. This is not automated. However, when called, it triggers all permission_classes has_object_permission function, just like in DRF Usage Let's create an APIController to manage Django user model import uuid from typing import List from ninja import ModelSchema from ninja_extra import APIController , route , router , exceptions , status from ninja_extra.controllers.response import Detail from django.contrib.auth import get_user_model class UserSchema ( ModelSchema ): class Config : model = get_user_model () model_fields = [ 'username' , 'email' , 'first_name' ] @router ( '/users' ) class UsersController ( APIController ): user_model = get_user_model () @route . post ( '' ) def create_user ( self , user : UserSchema ): # just simulating created user return self . Id ( uuid . uuid4 ()) @route . generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = UserSchema ) def update_user ( self , user_id : int ): \"\"\" Django Ninja will serialize Django ORM model to schema provided as `response`\"\"\" user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = Detail ( status_code = status . HTTP_204_NO_CONTENT )) def delete_user ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : user . delete () return self . create_response ( '' , status_code = status . HTTP_204_NO_CONTENT ) raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . get ( '' , response = List [ UserSchema ]) def list_user ( self ): return self . user_model . objects . all () @route . get ( '/ {user_id} ' , response = UserSchema ) def get_user_by_id ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' )","title":"APIController"},{"location":"tutorial/api_controller/#controller","text":"APIController is a borrowed term from C# environment. Controller is concept from MVC. Although Django is not an MVC framework, but we can mimic the concept generally. The APIController is an abstract class model that allows you to expose some class instance functions as route functions. It also supports dependency injection with Injector or Django injector . class APIController ( ABC , metaclass = APIControllerModelMetaclass ): ...","title":"Controller"},{"location":"tutorial/api_controller/#model-properties","text":"","title":"Model Properties"},{"location":"tutorial/api_controller/#permission_classes","text":"List of default permission classes defined in a controller router","title":"permission_classes"},{"location":"tutorial/api_controller/#auth","text":"List of default Authentication instances. As described in Django-Ninja Authentication . default: []","title":"auth"},{"location":"tutorial/api_controller/#api","text":"Instance of NinjaExtraAPI at runtime. default: None","title":"api"},{"location":"tutorial/api_controller/#auto_import","text":"states whether APIController should added to auto_controller import list. default: True","title":"auto_import"},{"location":"tutorial/api_controller/#get_routercls","text":"return controller to router instance if present and raises Exception is absent.","title":"get_router(cls)"},{"location":"tutorial/api_controller/#get_path_operationscls","text":"container dict of route definition which are pass to Django-Ninja at runtime","title":"get_path_operations(cls)"},{"location":"tutorial/api_controller/#add_operation_from_route_functioncls-route_function-routefunction","text":"A method overload for add_api_operation","title":"add_operation_from_route_function(cls, route_function: RouteFunction)"},{"location":"tutorial/api_controller/#add_api_operationcls","text":"Adds APIController route definitions to path operation","title":"add_api_operation(cls, ...)"},{"location":"tutorial/api_controller/#get_route_functionscls","text":"Gets all registered route in an APIController","title":"get_route_functions(cls)"},{"location":"tutorial/api_controller/#get_permissionsself","text":"Returns list of permission_classes instances","title":"get_permissions(self)"},{"location":"tutorial/api_controller/#check_permissionsself","text":"Check permission when route function is invoked","title":"check_permissions(self)"},{"location":"tutorial/api_controller/#check_object_permissionsself-obj-any","text":"Checks object permissions. This is not automated. However, when called, it triggers all permission_classes has_object_permission function, just like in DRF","title":"check_object_permissions(self, obj: Any)"},{"location":"tutorial/api_controller/#usage","text":"Let's create an APIController to manage Django user model import uuid from typing import List from ninja import ModelSchema from ninja_extra import APIController , route , router , exceptions , status from ninja_extra.controllers.response import Detail from django.contrib.auth import get_user_model class UserSchema ( ModelSchema ): class Config : model = get_user_model () model_fields = [ 'username' , 'email' , 'first_name' ] @router ( '/users' ) class UsersController ( APIController ): user_model = get_user_model () @route . post ( '' ) def create_user ( self , user : UserSchema ): # just simulating created user return self . Id ( uuid . uuid4 ()) @route . generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = UserSchema ) def update_user ( self , user_id : int ): \"\"\" Django Ninja will serialize Django ORM model to schema provided as `response`\"\"\" user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = Detail ( status_code = status . HTTP_204_NO_CONTENT )) def delete_user ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : user . delete () return self . create_response ( '' , status_code = status . HTTP_204_NO_CONTENT ) raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . get ( '' , response = List [ UserSchema ]) def list_user ( self ): return self . user_model . objects . all () @route . get ( '/ {user_id} ' , response = UserSchema ) def get_user_by_id ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' )","title":"Usage"},{"location":"tutorial/api_controller_permission/","text":"APIController Permissions The concept of these permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra . Limitations of object level permissions During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can't invoke has_object_permission . It has to be done manually Custom permissions To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , APIController , router , route class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @router ( \"\" , permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController ( APIController ): @route . get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word ) Permissions Supported Operands & (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: !(permissions.IsAuthenticated & ReadOnly)","title":"Controller Permissions"},{"location":"tutorial/api_controller_permission/#apicontroller-permissions","text":"The concept of these permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra .","title":"APIController Permissions"},{"location":"tutorial/api_controller_permission/#limitations-of-object-level-permissions","text":"During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can't invoke has_object_permission . It has to be done manually","title":"Limitations of object level permissions"},{"location":"tutorial/api_controller_permission/#custom-permissions","text":"To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , APIController , router , route class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @router ( \"\" , permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController ( APIController ): @route . get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word )","title":"Custom permissions"},{"location":"tutorial/api_controller_permission/#permissions-supported-operands","text":"& (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: !(permissions.IsAuthenticated & ReadOnly)","title":"Permissions Supported Operands"},{"location":"tutorial/api_controller_route/","text":"APIController Route Decorator The route class used as a function decorator in APIController class as you have since in APIController doc. It tells APIController class to expose a particular function as an endpoint. route decorator is more like django-ninja router class instance. The difference is route only defines controller endpoints and can only be used in APIController at the moment. Info ControllerRoute which is route and django-ninja router can't be used interchangeably For example from ninja_extra import route , APIController from ninja_extra.controllers import RouteFunction class MyController ( APIController ): @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route predefined method that helps create the following operations GET POST PUT DELETE PATCH GENERIC-for operation combination eg: methods=['POST', 'PATCH'] Initialization Parameters path it's a required uniques endpoint path string methods it's required a collection of endpoint operational mode eg: ['POST', 'PUT'] auth defines endpoint authentication method. default: NOT_SET response defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET operation_id it is an optional unique id that distinguishes operations in path view. default: NOT_SET summary it is an optional summary that describes your endpoint. default: None description it is an optional description that describes your endpoint. default: None tags It is a list of strings useful for endpoint grouping for documentation purpose. default: None deprecated it is an optional boolean parameter that declares an endpoint deprecated. default: None by_alias it is an optional parameter that is applied to filter response schema object. default: False exclude_unset it is an optional parameter that is applied to filter response schema object. default: False exclude_defaults it is an optional parameter that is applied to filter response schema object. default: False exclude_none it is an optional parameter that is applied to filter response schema object. default: False include_in_schema indicates whether an endpoint should appear on the swagger documentation. default: True url_name it gives a name to an endpoint which can be resolved using reverse function in django. default: None permissions defines collection route permission classes. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class Async Route Definition Django-Ninja-Extra route class also supports async endpoint definition. This is only available on Django > 3.0. For Example import asyncio from ninja_extra import route , APIController from ninja_extra.controllers import AsyncRouteFunction class MyController ( APIController ): @route . get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Controller Routes"},{"location":"tutorial/api_controller_route/#apicontroller-route-decorator","text":"The route class used as a function decorator in APIController class as you have since in APIController doc. It tells APIController class to expose a particular function as an endpoint. route decorator is more like django-ninja router class instance. The difference is route only defines controller endpoints and can only be used in APIController at the moment. Info ControllerRoute which is route and django-ninja router can't be used interchangeably For example from ninja_extra import route , APIController from ninja_extra.controllers import RouteFunction class MyController ( APIController ): @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route predefined method that helps create the following operations GET POST PUT DELETE PATCH GENERIC-for operation combination eg: methods=['POST', 'PATCH']","title":"APIController Route Decorator"},{"location":"tutorial/api_controller_route/#initialization-parameters","text":"","title":"Initialization Parameters"},{"location":"tutorial/api_controller_route/#path","text":"it's a required uniques endpoint path string","title":"path"},{"location":"tutorial/api_controller_route/#methods","text":"it's required a collection of endpoint operational mode eg: ['POST', 'PUT']","title":"methods"},{"location":"tutorial/api_controller_route/#auth","text":"defines endpoint authentication method. default: NOT_SET","title":"auth"},{"location":"tutorial/api_controller_route/#response","text":"defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET","title":"response"},{"location":"tutorial/api_controller_route/#operation_id","text":"it is an optional unique id that distinguishes operations in path view. default: NOT_SET","title":"operation_id"},{"location":"tutorial/api_controller_route/#summary","text":"it is an optional summary that describes your endpoint. default: None","title":"summary"},{"location":"tutorial/api_controller_route/#description","text":"it is an optional description that describes your endpoint. default: None","title":"description"},{"location":"tutorial/api_controller_route/#tags","text":"It is a list of strings useful for endpoint grouping for documentation purpose. default: None","title":"tags"},{"location":"tutorial/api_controller_route/#deprecated","text":"it is an optional boolean parameter that declares an endpoint deprecated. default: None","title":"deprecated"},{"location":"tutorial/api_controller_route/#by_alias","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"by_alias"},{"location":"tutorial/api_controller_route/#exclude_unset","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_unset"},{"location":"tutorial/api_controller_route/#exclude_defaults","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_defaults"},{"location":"tutorial/api_controller_route/#exclude_none","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_none"},{"location":"tutorial/api_controller_route/#include_in_schema","text":"indicates whether an endpoint should appear on the swagger documentation. default: True","title":"include_in_schema"},{"location":"tutorial/api_controller_route/#url_name","text":"it gives a name to an endpoint which can be resolved using reverse function in django. default: None","title":"url_name"},{"location":"tutorial/api_controller_route/#permissions","text":"defines collection route permission classes. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class","title":"permissions"},{"location":"tutorial/api_controller_route/#async-route-definition","text":"Django-Ninja-Extra route class also supports async endpoint definition. This is only available on Django > 3.0. For Example import asyncio from ninja_extra import route , APIController from ninja_extra.controllers import AsyncRouteFunction class MyController ( APIController ): @route . get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Async Route Definition"},{"location":"tutorial/api_controller_router/","text":"APIController Router The ControllerRouter which is router in short form, is an adapter class that adapts APIController classes to Django-Ninja router . During api.register_controllers call, the APIController _router is pass to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter class decoration Controller Router Initialization Parameters prefix it is a required parameter that defines extra route prefix for all route functions defined in an APIController class auth It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET tags It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None permissions It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None controller: Optional[Type[\"APIController\"]] It is APIController class decorated Quick Usage from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"Controller Router"},{"location":"tutorial/api_controller_router/#apicontroller-router","text":"The ControllerRouter which is router in short form, is an adapter class that adapts APIController classes to Django-Ninja router . During api.register_controllers call, the APIController _router is pass to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter class decoration","title":"APIController Router"},{"location":"tutorial/api_controller_router/#controller-router-initialization-parameters","text":"","title":"Controller Router Initialization Parameters"},{"location":"tutorial/api_controller_router/#prefix","text":"it is a required parameter that defines extra route prefix for all route functions defined in an APIController class","title":"prefix"},{"location":"tutorial/api_controller_router/#auth","text":"It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET","title":"auth"},{"location":"tutorial/api_controller_router/#tags","text":"It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None","title":"tags"},{"location":"tutorial/api_controller_router/#permissions","text":"It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None","title":"permissions"},{"location":"tutorial/api_controller_router/#controller-optionaltypeapicontroller","text":"It is APIController class decorated","title":"controller: Optional[Type[\"APIController\"]]"},{"location":"tutorial/api_controller_router/#quick-usage","text":"from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"Quick Usage"},{"location":"tutorial/authentication/","text":"Authentication Django Ninja Extra provides the same API for authorization and authentication. Automatic OpenAPI schema Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import APIController , route class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token class MyController ( APIController ): @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth } Global authentication In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication JWT Authentication if you want to use JWT authentication. See ninja-jwt","title":"Authentication"},{"location":"tutorial/authentication/#authentication","text":"Django Ninja Extra provides the same API for authorization and authentication.","title":"Authentication"},{"location":"tutorial/authentication/#automatic-openapi-schema","text":"Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import APIController , route class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token class MyController ( APIController ): @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth }","title":"Automatic OpenAPI schema"},{"location":"tutorial/authentication/#global-authentication","text":"In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication","title":"Global authentication"},{"location":"tutorial/authentication/#jwt-authentication","text":"if you want to use JWT authentication. See ninja-jwt","title":"JWT Authentication"},{"location":"tutorial/body_request/","text":"Request Body Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema . Info Read more on django-ninja body request Create your data model Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema from ninja_extra import APIController , route class Item ( Schema ): name : str description : str = None price : float quantity : int class ItemController ( APIController ): @route . post ( \"/items\" ) def create ( request , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Body Request"},{"location":"tutorial/body_request/#request-body","text":"Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema . Info Read more on django-ninja body request","title":"Request Body"},{"location":"tutorial/body_request/#create-your-data-model","text":"Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema from ninja_extra import APIController , route class Item ( Schema ): name : str description : str = None price : float quantity : int class ItemController ( APIController ): @route . post ( \"/items\" ) def create ( request , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Create your data model"},{"location":"tutorial/custom_exception/","text":"Custom Exception Django-Ninja provide a flask way of handling custom exceptions by registering its exception handlers. Django-Ninja-Extra creates an APIException class which provides similar functionalities, for those use to DRF APIException . For Example: from ninja_extra.exceptions import APIException from ninja_extra import status from ninja_extra import router , APIController , route , NinjaExtraAPI class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @router ( '/users' , tags = [ \"exception\" ]) class MyController ( APIController ): @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Exception"},{"location":"tutorial/custom_exception/#custom-exception","text":"Django-Ninja provide a flask way of handling custom exceptions by registering its exception handlers. Django-Ninja-Extra creates an APIException class which provides similar functionalities, for those use to DRF APIException . For Example: from ninja_extra.exceptions import APIException from ninja_extra import status from ninja_extra import router , APIController , route , NinjaExtraAPI class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @router ( '/users' , tags = [ \"exception\" ]) class MyController ( APIController ): @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Custom Exception"},{"location":"tutorial/pagination/","text":"Pagination Django Ninja Extra provides an intuitive pagination model. Usage from ninja_extra.pagination import paginate , PageNumberPaginationExtra from ninja_extra import router , APIController , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @router ( '/users' ) class UserController ( APIController ): @route . get ( '' , response = PageNumberPaginationExtra . get_response_schema ( schemas . UserSchema )) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Pagination"},{"location":"tutorial/pagination/#pagination","text":"Django Ninja Extra provides an intuitive pagination model.","title":"Pagination"},{"location":"tutorial/pagination/#usage","text":"from ninja_extra.pagination import paginate , PageNumberPaginationExtra from ninja_extra import router , APIController , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @router ( '/users' ) class UserController ( APIController ): @route . get ( '' , response = PageNumberPaginationExtra . get_response_schema ( schemas . UserSchema )) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Usage"},{"location":"tutorial/settings/","text":"Settings Some default configuration of NinjaExtra which can be overridden by defining NinjaExtra keyword in django settings.py as shown below: # Django project settings.py NINJA_EXTRA = { 'PAGINATION_CLASS' : \"ninja_extra.pagination.PageNumberPaginationExtra\" , 'PAGINATION_PER_PAGE' : 100 , 'INJECTOR_MODULES' : [], } PAGINATION_CLASS This defines the default paginator class used by paginate decorator function when a paginator class is not defined. default: ninja_extra.pagination.LimitOffsetPagination PAGINATION_PER_PAGE This defines the default page size in paginator class used by paginate decorator function when a page size is not defined. default: 100 INJECTOR_MODULES These are list of strings that defines injector module paths to be bound to Injector instance at app start up. default: []","title":"Settings"},{"location":"tutorial/settings/#settings","text":"Some default configuration of NinjaExtra which can be overridden by defining NinjaExtra keyword in django settings.py as shown below: # Django project settings.py NINJA_EXTRA = { 'PAGINATION_CLASS' : \"ninja_extra.pagination.PageNumberPaginationExtra\" , 'PAGINATION_PER_PAGE' : 100 , 'INJECTOR_MODULES' : [], }","title":"Settings"},{"location":"tutorial/settings/#pagination_class","text":"This defines the default paginator class used by paginate decorator function when a paginator class is not defined. default: ninja_extra.pagination.LimitOffsetPagination","title":"PAGINATION_CLASS"},{"location":"tutorial/settings/#pagination_per_page","text":"This defines the default page size in paginator class used by paginate decorator function when a page size is not defined. default: 100","title":"PAGINATION_PER_PAGE"},{"location":"tutorial/settings/#injector_modules","text":"These are list of strings that defines injector module paths to be bound to Injector instance at app start up. default: []","title":"INJECTOR_MODULES"},{"location":"tutorial/testing/","text":"Testing APIController Django Ninja Extra has a TestClient that provides seamless testing of APIController classes with pytest There are two test clients TestClient : for synchronous route functions TestClientAsync : for asynchronous route functions from ninja_extra.testing import TestClient from ninja_extra import APIController , route , router from ninja_extra.permissions import AllowAny @router ( '' , tags = [ 'Math' ], permissions = [ AllowAny ]) class MyMathController ( APIController ): @route . get ( '/add' ,) def add ( self , a : int , b : int ): \"\"\"add a to b\"\"\" return { \"result\" : a - b } @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } class TestMyMathController : def test_add_endpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/add' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == 8 # true def test_substraction_enpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/subtract' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == - 2 # true","title":"Testing"},{"location":"tutorial/testing/#testing-apicontroller","text":"Django Ninja Extra has a TestClient that provides seamless testing of APIController classes with pytest There are two test clients TestClient : for synchronous route functions TestClientAsync : for asynchronous route functions from ninja_extra.testing import TestClient from ninja_extra import APIController , route , router from ninja_extra.permissions import AllowAny @router ( '' , tags = [ 'Math' ], permissions = [ AllowAny ]) class MyMathController ( APIController ): @route . get ( '/add' ,) def add ( self , a : int , b : int ): \"\"\"add a to b\"\"\" return { \"result\" : a - b } @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } class TestMyMathController : def test_add_endpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/add' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == 8 # true def test_substraction_enpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/subtract' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == - 2 # true","title":"Testing APIController"},{"location":"tutorial/versioning/","text":"Versioning Different API version numbers With Django Ninja Extra it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , APIController , route , router @router ( '' ) class MyV1Controller ( APIController ): @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: from ninja_extra import NinjaExtraAPI , route , router from .api_v1 import MyV1Controller @router ( '' ) class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '2.0.0' ) api . register_controllers ( MyV2Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs Different business logic In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Versoning"},{"location":"tutorial/versioning/#versioning","text":"","title":"Versioning"},{"location":"tutorial/versioning/#different-api-version-numbers","text":"With Django Ninja Extra it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , APIController , route , router @router ( '' ) class MyV1Controller ( APIController ): @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: from ninja_extra import NinjaExtraAPI , route , router from .api_v1 import MyV1Controller @router ( '' ) class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '2.0.0' ) api . register_controllers ( MyV2Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs","title":"Different API version numbers"},{"location":"tutorial/versioning/#different-business-logic","text":"In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Different business logic"}]}